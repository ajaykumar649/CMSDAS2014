/********************************************************
* cint/cint/lib/dll_stl/G__cpp_climits.cxx
* CAUTION: DON'T CHANGE THIS FILE. THIS FILE IS AUTOMATICALLY GENERATED
*          FROM HEADER FILES LISTED IN G__setup_cpp_environmentXXX().
*          CHANGE THOSE HEADER FILES AND REGENERATE THIS FILE.
********************************************************/
#include "cint/cint/lib/dll_stl/G__cpp_climits.h" //newlink 3678 

#ifdef G__MEMTEST
#undef malloc
#undef free
#endif

#if defined(__GNUC__) && __GNUC__ >= 4 && ((__GNUC_MINOR__ == 2 && __GNUC_PATCHLEVEL__ >= 1) || (__GNUC_MINOR__ >= 3))
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif

extern "C" void G__cpp_reset_tagtable();

extern "C" void G__set_cpp_environment() {
  G__add_compiledheader("cint/cint/lib/dll_stl/clim.h");
  G__cpp_reset_tagtable();
}
#include <new>
extern "C" int G__cpp_dllrev() { return(30051515); }

/*********************************************************
* Member function Interface Method
*********************************************************/

/* numeric_limits<bool> */
static int G__climits_2_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) numeric_limits<bool>::min());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_2_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) numeric_limits<bool>::max());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_2_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) numeric_limits<bool>::epsilon());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_2_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) numeric_limits<bool>::round_error());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_2_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) numeric_limits<bool>::infinity());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_2_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) numeric_limits<bool>::quiet_NaN());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_2_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) numeric_limits<bool>::signaling_NaN());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_2_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) numeric_limits<bool>::denorm_min());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic default constructor
static int G__climits_2_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   numeric_limits<bool> *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new numeric_limits<bool>[n];
     } else {
       p = new((void*) gvp) numeric_limits<bool>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new numeric_limits<bool>;
     } else {
       p = new((void*) gvp) numeric_limits<bool>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__LN_numeric_limitslEboolgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__climits_2_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   numeric_limits<bool>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new numeric_limits<bool>(*(numeric_limits<bool>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__LN_numeric_limitslEboolgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef numeric_limits<bool> G__Tnumeric_limitslEboolgR;
static int G__climits_2_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (numeric_limits<bool>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((numeric_limits<bool>*) (soff+(sizeof(numeric_limits<bool>)*i)))->~G__Tnumeric_limitslEboolgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (numeric_limits<bool>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((numeric_limits<bool>*) (soff))->~G__Tnumeric_limitslEboolgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__climits_2_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   numeric_limits<bool>* dest = (numeric_limits<bool>*) G__getstructoffset();
   *dest = *(numeric_limits<bool>*) libp->para[0].ref;
   const numeric_limits<bool>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* numeric_limits<char> */
static int G__climits_3_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 99, (long) numeric_limits<char>::min());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_3_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 99, (long) numeric_limits<char>::max());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_3_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 99, (long) numeric_limits<char>::epsilon());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_3_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 99, (long) numeric_limits<char>::round_error());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_3_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 99, (long) numeric_limits<char>::infinity());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_3_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 99, (long) numeric_limits<char>::quiet_NaN());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_3_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 99, (long) numeric_limits<char>::signaling_NaN());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_3_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 99, (long) numeric_limits<char>::denorm_min());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic default constructor
static int G__climits_3_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   numeric_limits<char> *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new numeric_limits<char>[n];
     } else {
       p = new((void*) gvp) numeric_limits<char>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new numeric_limits<char>;
     } else {
       p = new((void*) gvp) numeric_limits<char>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__LN_numeric_limitslEchargR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__climits_3_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   numeric_limits<char>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new numeric_limits<char>(*(numeric_limits<char>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__LN_numeric_limitslEchargR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef numeric_limits<char> G__Tnumeric_limitslEchargR;
static int G__climits_3_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (numeric_limits<char>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((numeric_limits<char>*) (soff+(sizeof(numeric_limits<char>)*i)))->~G__Tnumeric_limitslEchargR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (numeric_limits<char>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((numeric_limits<char>*) (soff))->~G__Tnumeric_limitslEchargR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__climits_3_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   numeric_limits<char>* dest = (numeric_limits<char>*) G__getstructoffset();
   *dest = *(numeric_limits<char>*) libp->para[0].ref;
   const numeric_limits<char>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* numeric_limits<signed char> */
static int G__climits_4_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 99, (long) numeric_limits<signed char>::min());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_4_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 99, (long) numeric_limits<signed char>::max());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_4_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 99, (long) numeric_limits<signed char>::epsilon());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_4_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 99, (long) numeric_limits<signed char>::round_error());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_4_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 99, (long) numeric_limits<signed char>::infinity());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_4_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 99, (long) numeric_limits<signed char>::quiet_NaN());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_4_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 99, (long) numeric_limits<signed char>::signaling_NaN());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_4_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 99, (long) numeric_limits<signed char>::denorm_min());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic default constructor
static int G__climits_4_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   numeric_limits<signed char> *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new numeric_limits<signed char>[n];
     } else {
       p = new((void*) gvp) numeric_limits<signed char>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new numeric_limits<signed char>;
     } else {
       p = new((void*) gvp) numeric_limits<signed char>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__LN_numeric_limitslEsignedsPchargR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__climits_4_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   numeric_limits<signed char>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new numeric_limits<signed char>(*(numeric_limits<signed char>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__LN_numeric_limitslEsignedsPchargR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef numeric_limits<signed char> G__Tnumeric_limitslEsignedsPchargR;
static int G__climits_4_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (numeric_limits<signed char>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((numeric_limits<signed char>*) (soff+(sizeof(numeric_limits<signed char>)*i)))->~G__Tnumeric_limitslEsignedsPchargR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (numeric_limits<signed char>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((numeric_limits<signed char>*) (soff))->~G__Tnumeric_limitslEsignedsPchargR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__climits_4_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   numeric_limits<signed char>* dest = (numeric_limits<signed char>*) G__getstructoffset();
   *dest = *(numeric_limits<signed char>*) libp->para[0].ref;
   const numeric_limits<signed char>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* numeric_limits<unsigned char> */
static int G__climits_5_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 98, (long) numeric_limits<unsigned char>::min());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_5_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 98, (long) numeric_limits<unsigned char>::max());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_5_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 98, (long) numeric_limits<unsigned char>::epsilon());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_5_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 98, (long) numeric_limits<unsigned char>::round_error());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_5_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 98, (long) numeric_limits<unsigned char>::infinity());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_5_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 98, (long) numeric_limits<unsigned char>::quiet_NaN());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_5_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 98, (long) numeric_limits<unsigned char>::signaling_NaN());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_5_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 98, (long) numeric_limits<unsigned char>::denorm_min());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic default constructor
static int G__climits_5_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   numeric_limits<unsigned char> *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new numeric_limits<unsigned char>[n];
     } else {
       p = new((void*) gvp) numeric_limits<unsigned char>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new numeric_limits<unsigned char>;
     } else {
       p = new((void*) gvp) numeric_limits<unsigned char>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__LN_numeric_limitslEunsignedsPchargR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__climits_5_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   numeric_limits<unsigned char>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new numeric_limits<unsigned char>(*(numeric_limits<unsigned char>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__LN_numeric_limitslEunsignedsPchargR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef numeric_limits<unsigned char> G__Tnumeric_limitslEunsignedsPchargR;
static int G__climits_5_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (numeric_limits<unsigned char>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((numeric_limits<unsigned char>*) (soff+(sizeof(numeric_limits<unsigned char>)*i)))->~G__Tnumeric_limitslEunsignedsPchargR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (numeric_limits<unsigned char>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((numeric_limits<unsigned char>*) (soff))->~G__Tnumeric_limitslEunsignedsPchargR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__climits_5_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   numeric_limits<unsigned char>* dest = (numeric_limits<unsigned char>*) G__getstructoffset();
   *dest = *(numeric_limits<unsigned char>*) libp->para[0].ref;
   const numeric_limits<unsigned char>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* numeric_limits<unsigned int> */
static int G__climits_6_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) numeric_limits<unsigned int>::min());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_6_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) numeric_limits<unsigned int>::max());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_6_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) numeric_limits<unsigned int>::epsilon());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_6_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) numeric_limits<unsigned int>::round_error());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_6_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) numeric_limits<unsigned int>::infinity());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_6_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) numeric_limits<unsigned int>::quiet_NaN());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_6_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) numeric_limits<unsigned int>::signaling_NaN());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_6_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) numeric_limits<unsigned int>::denorm_min());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic default constructor
static int G__climits_6_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   numeric_limits<unsigned int> *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new numeric_limits<unsigned int>[n];
     } else {
       p = new((void*) gvp) numeric_limits<unsigned int>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new numeric_limits<unsigned int>;
     } else {
       p = new((void*) gvp) numeric_limits<unsigned int>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__LN_numeric_limitslEunsignedsPintgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__climits_6_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   numeric_limits<unsigned int>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new numeric_limits<unsigned int>(*(numeric_limits<unsigned int>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__LN_numeric_limitslEunsignedsPintgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef numeric_limits<unsigned int> G__Tnumeric_limitslEunsignedsPintgR;
static int G__climits_6_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (numeric_limits<unsigned int>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((numeric_limits<unsigned int>*) (soff+(sizeof(numeric_limits<unsigned int>)*i)))->~G__Tnumeric_limitslEunsignedsPintgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (numeric_limits<unsigned int>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((numeric_limits<unsigned int>*) (soff))->~G__Tnumeric_limitslEunsignedsPintgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__climits_6_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   numeric_limits<unsigned int>* dest = (numeric_limits<unsigned int>*) G__getstructoffset();
   *dest = *(numeric_limits<unsigned int>*) libp->para[0].ref;
   const numeric_limits<unsigned int>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* numeric_limits<short> */
static int G__climits_7_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) numeric_limits<short>::min());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_7_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) numeric_limits<short>::max());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_7_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) numeric_limits<short>::epsilon());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_7_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) numeric_limits<short>::round_error());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_7_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) numeric_limits<short>::infinity());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_7_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) numeric_limits<short>::quiet_NaN());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_7_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) numeric_limits<short>::signaling_NaN());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_7_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) numeric_limits<short>::denorm_min());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic default constructor
static int G__climits_7_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   numeric_limits<short> *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new numeric_limits<short>[n];
     } else {
       p = new((void*) gvp) numeric_limits<short>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new numeric_limits<short>;
     } else {
       p = new((void*) gvp) numeric_limits<short>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__LN_numeric_limitslEshortgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__climits_7_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   numeric_limits<short>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new numeric_limits<short>(*(numeric_limits<short>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__LN_numeric_limitslEshortgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef numeric_limits<short> G__Tnumeric_limitslEshortgR;
static int G__climits_7_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (numeric_limits<short>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((numeric_limits<short>*) (soff+(sizeof(numeric_limits<short>)*i)))->~G__Tnumeric_limitslEshortgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (numeric_limits<short>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((numeric_limits<short>*) (soff))->~G__Tnumeric_limitslEshortgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__climits_7_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   numeric_limits<short>* dest = (numeric_limits<short>*) G__getstructoffset();
   *dest = *(numeric_limits<short>*) libp->para[0].ref;
   const numeric_limits<short>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* numeric_limits<int> */
static int G__climits_8_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) numeric_limits<int>::min());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_8_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) numeric_limits<int>::max());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_8_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) numeric_limits<int>::epsilon());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_8_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) numeric_limits<int>::round_error());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_8_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) numeric_limits<int>::infinity());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_8_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) numeric_limits<int>::quiet_NaN());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_8_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) numeric_limits<int>::signaling_NaN());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_8_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) numeric_limits<int>::denorm_min());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic default constructor
static int G__climits_8_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   numeric_limits<int> *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new numeric_limits<int>[n];
     } else {
       p = new((void*) gvp) numeric_limits<int>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new numeric_limits<int>;
     } else {
       p = new((void*) gvp) numeric_limits<int>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__LN_numeric_limitslEintgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__climits_8_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   numeric_limits<int>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new numeric_limits<int>(*(numeric_limits<int>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__LN_numeric_limitslEintgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef numeric_limits<int> G__Tnumeric_limitslEintgR;
static int G__climits_8_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (numeric_limits<int>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((numeric_limits<int>*) (soff+(sizeof(numeric_limits<int>)*i)))->~G__Tnumeric_limitslEintgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (numeric_limits<int>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((numeric_limits<int>*) (soff))->~G__Tnumeric_limitslEintgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__climits_8_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   numeric_limits<int>* dest = (numeric_limits<int>*) G__getstructoffset();
   *dest = *(numeric_limits<int>*) libp->para[0].ref;
   const numeric_limits<int>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* numeric_limits<long> */
static int G__climits_9_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 108, (long) numeric_limits<long>::min());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_9_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 108, (long) numeric_limits<long>::max());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_9_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 108, (long) numeric_limits<long>::epsilon());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_9_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 108, (long) numeric_limits<long>::round_error());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_9_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 108, (long) numeric_limits<long>::infinity());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_9_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 108, (long) numeric_limits<long>::quiet_NaN());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_9_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 108, (long) numeric_limits<long>::signaling_NaN());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_9_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 108, (long) numeric_limits<long>::denorm_min());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic default constructor
static int G__climits_9_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   numeric_limits<long> *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new numeric_limits<long>[n];
     } else {
       p = new((void*) gvp) numeric_limits<long>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new numeric_limits<long>;
     } else {
       p = new((void*) gvp) numeric_limits<long>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__LN_numeric_limitslElonggR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__climits_9_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   numeric_limits<long>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new numeric_limits<long>(*(numeric_limits<long>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__LN_numeric_limitslElonggR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef numeric_limits<long> G__Tnumeric_limitslElonggR;
static int G__climits_9_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (numeric_limits<long>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((numeric_limits<long>*) (soff+(sizeof(numeric_limits<long>)*i)))->~G__Tnumeric_limitslElonggR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (numeric_limits<long>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((numeric_limits<long>*) (soff))->~G__Tnumeric_limitslElonggR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__climits_9_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   numeric_limits<long>* dest = (numeric_limits<long>*) G__getstructoffset();
   *dest = *(numeric_limits<long>*) libp->para[0].ref;
   const numeric_limits<long>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* numeric_limits<unsigned short> */
static int G__climits_10_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 114, (long) numeric_limits<unsigned short>::min());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_10_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 114, (long) numeric_limits<unsigned short>::max());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_10_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 114, (long) numeric_limits<unsigned short>::epsilon());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_10_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 114, (long) numeric_limits<unsigned short>::round_error());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_10_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 114, (long) numeric_limits<unsigned short>::infinity());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_10_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 114, (long) numeric_limits<unsigned short>::quiet_NaN());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_10_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 114, (long) numeric_limits<unsigned short>::signaling_NaN());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_10_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 114, (long) numeric_limits<unsigned short>::denorm_min());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic default constructor
static int G__climits_10_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   numeric_limits<unsigned short> *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new numeric_limits<unsigned short>[n];
     } else {
       p = new((void*) gvp) numeric_limits<unsigned short>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new numeric_limits<unsigned short>;
     } else {
       p = new((void*) gvp) numeric_limits<unsigned short>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__LN_numeric_limitslEunsignedsPshortgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__climits_10_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   numeric_limits<unsigned short>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new numeric_limits<unsigned short>(*(numeric_limits<unsigned short>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__LN_numeric_limitslEunsignedsPshortgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef numeric_limits<unsigned short> G__Tnumeric_limitslEunsignedsPshortgR;
static int G__climits_10_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (numeric_limits<unsigned short>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((numeric_limits<unsigned short>*) (soff+(sizeof(numeric_limits<unsigned short>)*i)))->~G__Tnumeric_limitslEunsignedsPshortgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (numeric_limits<unsigned short>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((numeric_limits<unsigned short>*) (soff))->~G__Tnumeric_limitslEunsignedsPshortgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__climits_10_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   numeric_limits<unsigned short>* dest = (numeric_limits<unsigned short>*) G__getstructoffset();
   *dest = *(numeric_limits<unsigned short>*) libp->para[0].ref;
   const numeric_limits<unsigned short>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* numeric_limits<unsigned long> */
static int G__climits_11_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) numeric_limits<unsigned long>::min());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_11_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) numeric_limits<unsigned long>::max());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_11_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) numeric_limits<unsigned long>::epsilon());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_11_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) numeric_limits<unsigned long>::round_error());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_11_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) numeric_limits<unsigned long>::infinity());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_11_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) numeric_limits<unsigned long>::quiet_NaN());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_11_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) numeric_limits<unsigned long>::signaling_NaN());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_11_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) numeric_limits<unsigned long>::denorm_min());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic default constructor
static int G__climits_11_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   numeric_limits<unsigned long> *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new numeric_limits<unsigned long>[n];
     } else {
       p = new((void*) gvp) numeric_limits<unsigned long>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new numeric_limits<unsigned long>;
     } else {
       p = new((void*) gvp) numeric_limits<unsigned long>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__LN_numeric_limitslEunsignedsPlonggR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__climits_11_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   numeric_limits<unsigned long>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new numeric_limits<unsigned long>(*(numeric_limits<unsigned long>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__LN_numeric_limitslEunsignedsPlonggR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef numeric_limits<unsigned long> G__Tnumeric_limitslEunsignedsPlonggR;
static int G__climits_11_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (numeric_limits<unsigned long>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((numeric_limits<unsigned long>*) (soff+(sizeof(numeric_limits<unsigned long>)*i)))->~G__Tnumeric_limitslEunsignedsPlonggR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (numeric_limits<unsigned long>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((numeric_limits<unsigned long>*) (soff))->~G__Tnumeric_limitslEunsignedsPlonggR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__climits_11_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   numeric_limits<unsigned long>* dest = (numeric_limits<unsigned long>*) G__getstructoffset();
   *dest = *(numeric_limits<unsigned long>*) libp->para[0].ref;
   const numeric_limits<unsigned long>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* numeric_limits<float> */
static int G__climits_12_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) numeric_limits<float>::min());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_12_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) numeric_limits<float>::max());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_12_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) numeric_limits<float>::epsilon());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_12_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) numeric_limits<float>::round_error());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_12_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) numeric_limits<float>::infinity());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_12_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) numeric_limits<float>::quiet_NaN());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_12_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) numeric_limits<float>::signaling_NaN());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_12_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) numeric_limits<float>::denorm_min());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic default constructor
static int G__climits_12_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   numeric_limits<float> *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new numeric_limits<float>[n];
     } else {
       p = new((void*) gvp) numeric_limits<float>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new numeric_limits<float>;
     } else {
       p = new((void*) gvp) numeric_limits<float>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__LN_numeric_limitslEfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__climits_12_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   numeric_limits<float>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new numeric_limits<float>(*(numeric_limits<float>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__LN_numeric_limitslEfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef numeric_limits<float> G__Tnumeric_limitslEfloatgR;
static int G__climits_12_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (numeric_limits<float>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((numeric_limits<float>*) (soff+(sizeof(numeric_limits<float>)*i)))->~G__Tnumeric_limitslEfloatgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (numeric_limits<float>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((numeric_limits<float>*) (soff))->~G__Tnumeric_limitslEfloatgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__climits_12_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   numeric_limits<float>* dest = (numeric_limits<float>*) G__getstructoffset();
   *dest = *(numeric_limits<float>*) libp->para[0].ref;
   const numeric_limits<float>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* numeric_limits<double> */
static int G__climits_13_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) numeric_limits<double>::min());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_13_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) numeric_limits<double>::max());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_13_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) numeric_limits<double>::epsilon());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_13_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) numeric_limits<double>::round_error());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_13_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) numeric_limits<double>::infinity());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_13_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) numeric_limits<double>::quiet_NaN());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_13_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) numeric_limits<double>::signaling_NaN());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_13_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) numeric_limits<double>::denorm_min());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic default constructor
static int G__climits_13_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   numeric_limits<double> *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new numeric_limits<double>[n];
     } else {
       p = new((void*) gvp) numeric_limits<double>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new numeric_limits<double>;
     } else {
       p = new((void*) gvp) numeric_limits<double>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__LN_numeric_limitslEdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__climits_13_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   numeric_limits<double>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new numeric_limits<double>(*(numeric_limits<double>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__LN_numeric_limitslEdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef numeric_limits<double> G__Tnumeric_limitslEdoublegR;
static int G__climits_13_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (numeric_limits<double>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((numeric_limits<double>*) (soff+(sizeof(numeric_limits<double>)*i)))->~G__Tnumeric_limitslEdoublegR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (numeric_limits<double>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((numeric_limits<double>*) (soff))->~G__Tnumeric_limitslEdoublegR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__climits_13_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   numeric_limits<double>* dest = (numeric_limits<double>*) G__getstructoffset();
   *dest = *(numeric_limits<double>*) libp->para[0].ref;
   const numeric_limits<double>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* numeric_limits<long double> */
static int G__climits_14_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letLongdouble(result7, 113, (long double) numeric_limits<long double>::min());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_14_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letLongdouble(result7, 113, (long double) numeric_limits<long double>::max());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_14_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letLongdouble(result7, 113, (long double) numeric_limits<long double>::epsilon());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_14_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letLongdouble(result7, 113, (long double) numeric_limits<long double>::round_error());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_14_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letLongdouble(result7, 113, (long double) numeric_limits<long double>::infinity());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_14_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letLongdouble(result7, 113, (long double) numeric_limits<long double>::quiet_NaN());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_14_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letLongdouble(result7, 113, (long double) numeric_limits<long double>::signaling_NaN());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__climits_14_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letLongdouble(result7, 113, (long double) numeric_limits<long double>::denorm_min());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic default constructor
static int G__climits_14_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   numeric_limits<long double> *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new numeric_limits<long double>[n];
     } else {
       p = new((void*) gvp) numeric_limits<long double>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new numeric_limits<long double>;
     } else {
       p = new((void*) gvp) numeric_limits<long double>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__LN_numeric_limitslElongsPdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__climits_14_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   numeric_limits<long double>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new numeric_limits<long double>(*(numeric_limits<long double>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__LN_numeric_limitslElongsPdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef numeric_limits<long double> G__Tnumeric_limitslElongsPdoublegR;
static int G__climits_14_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (numeric_limits<long double>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((numeric_limits<long double>*) (soff+(sizeof(numeric_limits<long double>)*i)))->~G__Tnumeric_limitslElongsPdoublegR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (numeric_limits<long double>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((numeric_limits<long double>*) (soff))->~G__Tnumeric_limitslElongsPdoublegR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__climits_14_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   numeric_limits<long double>* dest = (numeric_limits<long double>*) G__getstructoffset();
   *dest = *(numeric_limits<long double>*) libp->para[0].ref;
   const numeric_limits<long double>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Setting up global function */

/*********************************************************
* Member function Stub
*********************************************************/

/* numeric_limits<bool> */

/* numeric_limits<char> */

/* numeric_limits<signed char> */

/* numeric_limits<unsigned char> */

/* numeric_limits<unsigned int> */

/* numeric_limits<short> */

/* numeric_limits<int> */

/* numeric_limits<long> */

/* numeric_limits<unsigned short> */

/* numeric_limits<unsigned long> */

/* numeric_limits<float> */

/* numeric_limits<double> */

/* numeric_limits<long double> */

/*********************************************************
* Global function Stub
*********************************************************/

/*********************************************************
* Get size of pointer to member function
*********************************************************/
class G__Sizep2memfunc {
 public:
  G__Sizep2memfunc(): p(&G__Sizep2memfunc::sizep2memfunc) {}
    size_t sizep2memfunc() { return(sizeof(p)); }
  private:
    size_t (G__Sizep2memfunc::*p)();
};

size_t G__get_sizep2memfunc()
{
  G__Sizep2memfunc a;
  G__setsizep2memfunc((int)a.sizep2memfunc());
  return((size_t)a.sizep2memfunc());
}


/*********************************************************
* virtual base class offset calculation interface
*********************************************************/

   /* Setting up class inheritance */

/*********************************************************
* Inheritance information setup/
*********************************************************/
extern "C" void G__cpp_setup_inheritance() {

   /* Setting up class inheritance */
}

/*********************************************************
* typedef information setup/
*********************************************************/
extern "C" void G__cpp_setup_typetable() {

   /* Setting up typedef entry */
   G__search_typename2("numeric_limits<wchar_t>",117,G__get_linked_tagnum(&G__LN_numeric_limitslEunsignedsPintgR),0,-1);
   G__setnewtype(-1,NULL,0);
}

/*********************************************************
* Data Member information setup/
*********************************************************/

   /* Setting up class,struct,union tag member variable */

   /* numeric_limits<bool> */
static void G__setup_memvarnumeric_limitslEboolgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__LN_numeric_limitslEboolgR));
   { numeric_limits<bool> *p; p=(numeric_limits<bool>*)0x1000; if (p) { }
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_specialized=%lldLL",(long long)numeric_limits<bool>::is_specialized).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("digits=%lldLL",(long long)numeric_limits<bool>::digits).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("digits10=%lldLL",(long long)numeric_limits<bool>::digits10).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_signed=%lldLL",(long long)numeric_limits<bool>::is_signed).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_integer=%lldLL",(long long)numeric_limits<bool>::is_integer).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_exact=%lldLL",(long long)numeric_limits<bool>::is_exact).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("radix=%lldLL",(long long)numeric_limits<bool>::radix).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("min_exponent=%lldLL",(long long)numeric_limits<bool>::min_exponent).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("min_exponent10=%lldLL",(long long)numeric_limits<bool>::min_exponent10).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("max_exponent=%lldLL",(long long)numeric_limits<bool>::max_exponent).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("max_exponent10=%lldLL",(long long)numeric_limits<bool>::max_exponent10).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_infinity=%lldLL",(long long)numeric_limits<bool>::has_infinity).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_quiet_NaN=%lldLL",(long long)numeric_limits<bool>::has_quiet_NaN).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_signaling_NaN=%lldLL",(long long)numeric_limits<bool>::has_signaling_NaN).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__LN_float_denorm_style),-1,-2,1,G__FastAllocString(2048).Format("has_denorm=%lldLL",(long long)numeric_limits<bool>::has_denorm).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_denorm_loss=%lldLL",(long long)numeric_limits<bool>::has_denorm_loss).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_iec559=%lldLL",(long long)numeric_limits<bool>::is_iec559).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_bounded=%lldLL",(long long)numeric_limits<bool>::is_bounded).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_modulo=%lldLL",(long long)numeric_limits<bool>::is_modulo).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("traps=%lldLL",(long long)numeric_limits<bool>::traps).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("tinyness_before=%lldLL",(long long)numeric_limits<bool>::tinyness_before).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__LN_float_round_style),-1,-2,1,G__FastAllocString(2048).Format("round_style=%lldLL",(long long)numeric_limits<bool>::round_style).data(),0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* numeric_limits<char> */
static void G__setup_memvarnumeric_limitslEchargR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__LN_numeric_limitslEchargR));
   { numeric_limits<char> *p; p=(numeric_limits<char>*)0x1000; if (p) { }
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_specialized=%lldLL",(long long)numeric_limits<char>::is_specialized).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("digits=%lldLL",(long long)numeric_limits<char>::digits).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("digits10=%lldLL",(long long)numeric_limits<char>::digits10).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_signed=%lldLL",(long long)numeric_limits<char>::is_signed).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_integer=%lldLL",(long long)numeric_limits<char>::is_integer).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_exact=%lldLL",(long long)numeric_limits<char>::is_exact).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("radix=%lldLL",(long long)numeric_limits<char>::radix).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("min_exponent=%lldLL",(long long)numeric_limits<char>::min_exponent).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("min_exponent10=%lldLL",(long long)numeric_limits<char>::min_exponent10).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("max_exponent=%lldLL",(long long)numeric_limits<char>::max_exponent).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("max_exponent10=%lldLL",(long long)numeric_limits<char>::max_exponent10).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_infinity=%lldLL",(long long)numeric_limits<char>::has_infinity).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_quiet_NaN=%lldLL",(long long)numeric_limits<char>::has_quiet_NaN).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_signaling_NaN=%lldLL",(long long)numeric_limits<char>::has_signaling_NaN).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__LN_float_denorm_style),-1,-2,1,G__FastAllocString(2048).Format("has_denorm=%lldLL",(long long)numeric_limits<char>::has_denorm).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_denorm_loss=%lldLL",(long long)numeric_limits<char>::has_denorm_loss).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_iec559=%lldLL",(long long)numeric_limits<char>::is_iec559).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_bounded=%lldLL",(long long)numeric_limits<char>::is_bounded).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_modulo=%lldLL",(long long)numeric_limits<char>::is_modulo).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("traps=%lldLL",(long long)numeric_limits<char>::traps).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("tinyness_before=%lldLL",(long long)numeric_limits<char>::tinyness_before).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__LN_float_round_style),-1,-2,1,G__FastAllocString(2048).Format("round_style=%lldLL",(long long)numeric_limits<char>::round_style).data(),0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* numeric_limits<signed char> */
static void G__setup_memvarnumeric_limitslEsignedsPchargR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__LN_numeric_limitslEsignedsPchargR));
   { numeric_limits<signed char> *p; p=(numeric_limits<signed char>*)0x1000; if (p) { }
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_specialized=%lldLL",(long long)numeric_limits<signed char>::is_specialized).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("digits=%lldLL",(long long)numeric_limits<signed char>::digits).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("digits10=%lldLL",(long long)numeric_limits<signed char>::digits10).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_signed=%lldLL",(long long)numeric_limits<signed char>::is_signed).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_integer=%lldLL",(long long)numeric_limits<signed char>::is_integer).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_exact=%lldLL",(long long)numeric_limits<signed char>::is_exact).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("radix=%lldLL",(long long)numeric_limits<signed char>::radix).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("min_exponent=%lldLL",(long long)numeric_limits<signed char>::min_exponent).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("min_exponent10=%lldLL",(long long)numeric_limits<signed char>::min_exponent10).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("max_exponent=%lldLL",(long long)numeric_limits<signed char>::max_exponent).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("max_exponent10=%lldLL",(long long)numeric_limits<signed char>::max_exponent10).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_infinity=%lldLL",(long long)numeric_limits<signed char>::has_infinity).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_quiet_NaN=%lldLL",(long long)numeric_limits<signed char>::has_quiet_NaN).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_signaling_NaN=%lldLL",(long long)numeric_limits<signed char>::has_signaling_NaN).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__LN_float_denorm_style),-1,-2,1,G__FastAllocString(2048).Format("has_denorm=%lldLL",(long long)numeric_limits<signed char>::has_denorm).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_denorm_loss=%lldLL",(long long)numeric_limits<signed char>::has_denorm_loss).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_iec559=%lldLL",(long long)numeric_limits<signed char>::is_iec559).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_bounded=%lldLL",(long long)numeric_limits<signed char>::is_bounded).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_modulo=%lldLL",(long long)numeric_limits<signed char>::is_modulo).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("traps=%lldLL",(long long)numeric_limits<signed char>::traps).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("tinyness_before=%lldLL",(long long)numeric_limits<signed char>::tinyness_before).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__LN_float_round_style),-1,-2,1,G__FastAllocString(2048).Format("round_style=%lldLL",(long long)numeric_limits<signed char>::round_style).data(),0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* numeric_limits<unsigned char> */
static void G__setup_memvarnumeric_limitslEunsignedsPchargR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__LN_numeric_limitslEunsignedsPchargR));
   { numeric_limits<unsigned char> *p; p=(numeric_limits<unsigned char>*)0x1000; if (p) { }
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_specialized=%lldLL",(long long)numeric_limits<unsigned char>::is_specialized).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("digits=%lldLL",(long long)numeric_limits<unsigned char>::digits).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("digits10=%lldLL",(long long)numeric_limits<unsigned char>::digits10).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_signed=%lldLL",(long long)numeric_limits<unsigned char>::is_signed).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_integer=%lldLL",(long long)numeric_limits<unsigned char>::is_integer).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_exact=%lldLL",(long long)numeric_limits<unsigned char>::is_exact).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("radix=%lldLL",(long long)numeric_limits<unsigned char>::radix).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("min_exponent=%lldLL",(long long)numeric_limits<unsigned char>::min_exponent).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("min_exponent10=%lldLL",(long long)numeric_limits<unsigned char>::min_exponent10).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("max_exponent=%lldLL",(long long)numeric_limits<unsigned char>::max_exponent).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("max_exponent10=%lldLL",(long long)numeric_limits<unsigned char>::max_exponent10).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_infinity=%lldLL",(long long)numeric_limits<unsigned char>::has_infinity).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_quiet_NaN=%lldLL",(long long)numeric_limits<unsigned char>::has_quiet_NaN).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_signaling_NaN=%lldLL",(long long)numeric_limits<unsigned char>::has_signaling_NaN).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__LN_float_denorm_style),-1,-2,1,G__FastAllocString(2048).Format("has_denorm=%lldLL",(long long)numeric_limits<unsigned char>::has_denorm).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_denorm_loss=%lldLL",(long long)numeric_limits<unsigned char>::has_denorm_loss).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_iec559=%lldLL",(long long)numeric_limits<unsigned char>::is_iec559).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_bounded=%lldLL",(long long)numeric_limits<unsigned char>::is_bounded).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_modulo=%lldLL",(long long)numeric_limits<unsigned char>::is_modulo).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("traps=%lldLL",(long long)numeric_limits<unsigned char>::traps).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("tinyness_before=%lldLL",(long long)numeric_limits<unsigned char>::tinyness_before).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__LN_float_round_style),-1,-2,1,G__FastAllocString(2048).Format("round_style=%lldLL",(long long)numeric_limits<unsigned char>::round_style).data(),0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* numeric_limits<unsigned int> */
static void G__setup_memvarnumeric_limitslEunsignedsPintgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__LN_numeric_limitslEunsignedsPintgR));
   { numeric_limits<unsigned int> *p; p=(numeric_limits<unsigned int>*)0x1000; if (p) { }
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_specialized=%lldLL",(long long)numeric_limits<unsigned int>::is_specialized).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("digits=%lldLL",(long long)numeric_limits<unsigned int>::digits).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("digits10=%lldLL",(long long)numeric_limits<unsigned int>::digits10).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_signed=%lldLL",(long long)numeric_limits<unsigned int>::is_signed).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_integer=%lldLL",(long long)numeric_limits<unsigned int>::is_integer).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_exact=%lldLL",(long long)numeric_limits<unsigned int>::is_exact).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("radix=%lldLL",(long long)numeric_limits<unsigned int>::radix).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("min_exponent=%lldLL",(long long)numeric_limits<unsigned int>::min_exponent).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("min_exponent10=%lldLL",(long long)numeric_limits<unsigned int>::min_exponent10).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("max_exponent=%lldLL",(long long)numeric_limits<unsigned int>::max_exponent).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("max_exponent10=%lldLL",(long long)numeric_limits<unsigned int>::max_exponent10).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_infinity=%lldLL",(long long)numeric_limits<unsigned int>::has_infinity).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_quiet_NaN=%lldLL",(long long)numeric_limits<unsigned int>::has_quiet_NaN).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_signaling_NaN=%lldLL",(long long)numeric_limits<unsigned int>::has_signaling_NaN).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__LN_float_denorm_style),-1,-2,1,G__FastAllocString(2048).Format("has_denorm=%lldLL",(long long)numeric_limits<unsigned int>::has_denorm).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_denorm_loss=%lldLL",(long long)numeric_limits<unsigned int>::has_denorm_loss).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_iec559=%lldLL",(long long)numeric_limits<unsigned int>::is_iec559).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_bounded=%lldLL",(long long)numeric_limits<unsigned int>::is_bounded).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_modulo=%lldLL",(long long)numeric_limits<unsigned int>::is_modulo).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("traps=%lldLL",(long long)numeric_limits<unsigned int>::traps).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("tinyness_before=%lldLL",(long long)numeric_limits<unsigned int>::tinyness_before).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__LN_float_round_style),-1,-2,1,G__FastAllocString(2048).Format("round_style=%lldLL",(long long)numeric_limits<unsigned int>::round_style).data(),0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* numeric_limits<short> */
static void G__setup_memvarnumeric_limitslEshortgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__LN_numeric_limitslEshortgR));
   { numeric_limits<short> *p; p=(numeric_limits<short>*)0x1000; if (p) { }
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_specialized=%lldLL",(long long)numeric_limits<short>::is_specialized).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("digits=%lldLL",(long long)numeric_limits<short>::digits).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("digits10=%lldLL",(long long)numeric_limits<short>::digits10).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_signed=%lldLL",(long long)numeric_limits<short>::is_signed).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_integer=%lldLL",(long long)numeric_limits<short>::is_integer).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_exact=%lldLL",(long long)numeric_limits<short>::is_exact).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("radix=%lldLL",(long long)numeric_limits<short>::radix).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("min_exponent=%lldLL",(long long)numeric_limits<short>::min_exponent).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("min_exponent10=%lldLL",(long long)numeric_limits<short>::min_exponent10).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("max_exponent=%lldLL",(long long)numeric_limits<short>::max_exponent).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("max_exponent10=%lldLL",(long long)numeric_limits<short>::max_exponent10).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_infinity=%lldLL",(long long)numeric_limits<short>::has_infinity).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_quiet_NaN=%lldLL",(long long)numeric_limits<short>::has_quiet_NaN).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_signaling_NaN=%lldLL",(long long)numeric_limits<short>::has_signaling_NaN).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__LN_float_denorm_style),-1,-2,1,G__FastAllocString(2048).Format("has_denorm=%lldLL",(long long)numeric_limits<short>::has_denorm).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_denorm_loss=%lldLL",(long long)numeric_limits<short>::has_denorm_loss).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_iec559=%lldLL",(long long)numeric_limits<short>::is_iec559).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_bounded=%lldLL",(long long)numeric_limits<short>::is_bounded).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_modulo=%lldLL",(long long)numeric_limits<short>::is_modulo).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("traps=%lldLL",(long long)numeric_limits<short>::traps).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("tinyness_before=%lldLL",(long long)numeric_limits<short>::tinyness_before).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__LN_float_round_style),-1,-2,1,G__FastAllocString(2048).Format("round_style=%lldLL",(long long)numeric_limits<short>::round_style).data(),0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* numeric_limits<int> */
static void G__setup_memvarnumeric_limitslEintgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__LN_numeric_limitslEintgR));
   { numeric_limits<int> *p; p=(numeric_limits<int>*)0x1000; if (p) { }
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_specialized=%lldLL",(long long)numeric_limits<int>::is_specialized).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("digits=%lldLL",(long long)numeric_limits<int>::digits).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("digits10=%lldLL",(long long)numeric_limits<int>::digits10).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_signed=%lldLL",(long long)numeric_limits<int>::is_signed).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_integer=%lldLL",(long long)numeric_limits<int>::is_integer).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_exact=%lldLL",(long long)numeric_limits<int>::is_exact).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("radix=%lldLL",(long long)numeric_limits<int>::radix).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("min_exponent=%lldLL",(long long)numeric_limits<int>::min_exponent).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("min_exponent10=%lldLL",(long long)numeric_limits<int>::min_exponent10).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("max_exponent=%lldLL",(long long)numeric_limits<int>::max_exponent).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("max_exponent10=%lldLL",(long long)numeric_limits<int>::max_exponent10).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_infinity=%lldLL",(long long)numeric_limits<int>::has_infinity).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_quiet_NaN=%lldLL",(long long)numeric_limits<int>::has_quiet_NaN).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_signaling_NaN=%lldLL",(long long)numeric_limits<int>::has_signaling_NaN).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__LN_float_denorm_style),-1,-2,1,G__FastAllocString(2048).Format("has_denorm=%lldLL",(long long)numeric_limits<int>::has_denorm).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_denorm_loss=%lldLL",(long long)numeric_limits<int>::has_denorm_loss).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_iec559=%lldLL",(long long)numeric_limits<int>::is_iec559).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_bounded=%lldLL",(long long)numeric_limits<int>::is_bounded).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_modulo=%lldLL",(long long)numeric_limits<int>::is_modulo).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("traps=%lldLL",(long long)numeric_limits<int>::traps).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("tinyness_before=%lldLL",(long long)numeric_limits<int>::tinyness_before).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__LN_float_round_style),-1,-2,1,G__FastAllocString(2048).Format("round_style=%lldLL",(long long)numeric_limits<int>::round_style).data(),0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* numeric_limits<long> */
static void G__setup_memvarnumeric_limitslElonggR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__LN_numeric_limitslElonggR));
   { numeric_limits<long> *p; p=(numeric_limits<long>*)0x1000; if (p) { }
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_specialized=%lldLL",(long long)numeric_limits<long>::is_specialized).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("digits=%lldLL",(long long)numeric_limits<long>::digits).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("digits10=%lldLL",(long long)numeric_limits<long>::digits10).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_signed=%lldLL",(long long)numeric_limits<long>::is_signed).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_integer=%lldLL",(long long)numeric_limits<long>::is_integer).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_exact=%lldLL",(long long)numeric_limits<long>::is_exact).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("radix=%lldLL",(long long)numeric_limits<long>::radix).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("min_exponent=%lldLL",(long long)numeric_limits<long>::min_exponent).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("min_exponent10=%lldLL",(long long)numeric_limits<long>::min_exponent10).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("max_exponent=%lldLL",(long long)numeric_limits<long>::max_exponent).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("max_exponent10=%lldLL",(long long)numeric_limits<long>::max_exponent10).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_infinity=%lldLL",(long long)numeric_limits<long>::has_infinity).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_quiet_NaN=%lldLL",(long long)numeric_limits<long>::has_quiet_NaN).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_signaling_NaN=%lldLL",(long long)numeric_limits<long>::has_signaling_NaN).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__LN_float_denorm_style),-1,-2,1,G__FastAllocString(2048).Format("has_denorm=%lldLL",(long long)numeric_limits<long>::has_denorm).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_denorm_loss=%lldLL",(long long)numeric_limits<long>::has_denorm_loss).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_iec559=%lldLL",(long long)numeric_limits<long>::is_iec559).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_bounded=%lldLL",(long long)numeric_limits<long>::is_bounded).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_modulo=%lldLL",(long long)numeric_limits<long>::is_modulo).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("traps=%lldLL",(long long)numeric_limits<long>::traps).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("tinyness_before=%lldLL",(long long)numeric_limits<long>::tinyness_before).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__LN_float_round_style),-1,-2,1,G__FastAllocString(2048).Format("round_style=%lldLL",(long long)numeric_limits<long>::round_style).data(),0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* numeric_limits<unsigned short> */
static void G__setup_memvarnumeric_limitslEunsignedsPshortgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__LN_numeric_limitslEunsignedsPshortgR));
   { numeric_limits<unsigned short> *p; p=(numeric_limits<unsigned short>*)0x1000; if (p) { }
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_specialized=%lldLL",(long long)numeric_limits<unsigned short>::is_specialized).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("digits=%lldLL",(long long)numeric_limits<unsigned short>::digits).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("digits10=%lldLL",(long long)numeric_limits<unsigned short>::digits10).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_signed=%lldLL",(long long)numeric_limits<unsigned short>::is_signed).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_integer=%lldLL",(long long)numeric_limits<unsigned short>::is_integer).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_exact=%lldLL",(long long)numeric_limits<unsigned short>::is_exact).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("radix=%lldLL",(long long)numeric_limits<unsigned short>::radix).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("min_exponent=%lldLL",(long long)numeric_limits<unsigned short>::min_exponent).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("min_exponent10=%lldLL",(long long)numeric_limits<unsigned short>::min_exponent10).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("max_exponent=%lldLL",(long long)numeric_limits<unsigned short>::max_exponent).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("max_exponent10=%lldLL",(long long)numeric_limits<unsigned short>::max_exponent10).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_infinity=%lldLL",(long long)numeric_limits<unsigned short>::has_infinity).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_quiet_NaN=%lldLL",(long long)numeric_limits<unsigned short>::has_quiet_NaN).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_signaling_NaN=%lldLL",(long long)numeric_limits<unsigned short>::has_signaling_NaN).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__LN_float_denorm_style),-1,-2,1,G__FastAllocString(2048).Format("has_denorm=%lldLL",(long long)numeric_limits<unsigned short>::has_denorm).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_denorm_loss=%lldLL",(long long)numeric_limits<unsigned short>::has_denorm_loss).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_iec559=%lldLL",(long long)numeric_limits<unsigned short>::is_iec559).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_bounded=%lldLL",(long long)numeric_limits<unsigned short>::is_bounded).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_modulo=%lldLL",(long long)numeric_limits<unsigned short>::is_modulo).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("traps=%lldLL",(long long)numeric_limits<unsigned short>::traps).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("tinyness_before=%lldLL",(long long)numeric_limits<unsigned short>::tinyness_before).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__LN_float_round_style),-1,-2,1,G__FastAllocString(2048).Format("round_style=%lldLL",(long long)numeric_limits<unsigned short>::round_style).data(),0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* numeric_limits<unsigned long> */
static void G__setup_memvarnumeric_limitslEunsignedsPlonggR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__LN_numeric_limitslEunsignedsPlonggR));
   { numeric_limits<unsigned long> *p; p=(numeric_limits<unsigned long>*)0x1000; if (p) { }
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_specialized=%lldLL",(long long)numeric_limits<unsigned long>::is_specialized).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("digits=%lldLL",(long long)numeric_limits<unsigned long>::digits).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("digits10=%lldLL",(long long)numeric_limits<unsigned long>::digits10).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_signed=%lldLL",(long long)numeric_limits<unsigned long>::is_signed).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_integer=%lldLL",(long long)numeric_limits<unsigned long>::is_integer).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_exact=%lldLL",(long long)numeric_limits<unsigned long>::is_exact).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("radix=%lldLL",(long long)numeric_limits<unsigned long>::radix).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("min_exponent=%lldLL",(long long)numeric_limits<unsigned long>::min_exponent).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("min_exponent10=%lldLL",(long long)numeric_limits<unsigned long>::min_exponent10).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("max_exponent=%lldLL",(long long)numeric_limits<unsigned long>::max_exponent).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("max_exponent10=%lldLL",(long long)numeric_limits<unsigned long>::max_exponent10).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_infinity=%lldLL",(long long)numeric_limits<unsigned long>::has_infinity).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_quiet_NaN=%lldLL",(long long)numeric_limits<unsigned long>::has_quiet_NaN).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_signaling_NaN=%lldLL",(long long)numeric_limits<unsigned long>::has_signaling_NaN).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__LN_float_denorm_style),-1,-2,1,G__FastAllocString(2048).Format("has_denorm=%lldLL",(long long)numeric_limits<unsigned long>::has_denorm).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_denorm_loss=%lldLL",(long long)numeric_limits<unsigned long>::has_denorm_loss).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_iec559=%lldLL",(long long)numeric_limits<unsigned long>::is_iec559).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_bounded=%lldLL",(long long)numeric_limits<unsigned long>::is_bounded).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_modulo=%lldLL",(long long)numeric_limits<unsigned long>::is_modulo).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("traps=%lldLL",(long long)numeric_limits<unsigned long>::traps).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("tinyness_before=%lldLL",(long long)numeric_limits<unsigned long>::tinyness_before).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__LN_float_round_style),-1,-2,1,G__FastAllocString(2048).Format("round_style=%lldLL",(long long)numeric_limits<unsigned long>::round_style).data(),0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* numeric_limits<float> */
static void G__setup_memvarnumeric_limitslEfloatgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__LN_numeric_limitslEfloatgR));
   { numeric_limits<float> *p; p=(numeric_limits<float>*)0x1000; if (p) { }
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_specialized=%lldLL",(long long)numeric_limits<float>::is_specialized).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("digits=%lldLL",(long long)numeric_limits<float>::digits).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("digits10=%lldLL",(long long)numeric_limits<float>::digits10).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_signed=%lldLL",(long long)numeric_limits<float>::is_signed).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_integer=%lldLL",(long long)numeric_limits<float>::is_integer).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_exact=%lldLL",(long long)numeric_limits<float>::is_exact).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("radix=%lldLL",(long long)numeric_limits<float>::radix).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("min_exponent=%lldLL",(long long)numeric_limits<float>::min_exponent).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("min_exponent10=%lldLL",(long long)numeric_limits<float>::min_exponent10).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("max_exponent=%lldLL",(long long)numeric_limits<float>::max_exponent).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("max_exponent10=%lldLL",(long long)numeric_limits<float>::max_exponent10).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_infinity=%lldLL",(long long)numeric_limits<float>::has_infinity).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_quiet_NaN=%lldLL",(long long)numeric_limits<float>::has_quiet_NaN).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_signaling_NaN=%lldLL",(long long)numeric_limits<float>::has_signaling_NaN).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__LN_float_denorm_style),-1,-2,1,G__FastAllocString(2048).Format("has_denorm=%lldLL",(long long)numeric_limits<float>::has_denorm).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_denorm_loss=%lldLL",(long long)numeric_limits<float>::has_denorm_loss).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_iec559=%lldLL",(long long)numeric_limits<float>::is_iec559).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_bounded=%lldLL",(long long)numeric_limits<float>::is_bounded).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_modulo=%lldLL",(long long)numeric_limits<float>::is_modulo).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("traps=%lldLL",(long long)numeric_limits<float>::traps).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("tinyness_before=%lldLL",(long long)numeric_limits<float>::tinyness_before).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__LN_float_round_style),-1,-2,1,G__FastAllocString(2048).Format("round_style=%lldLL",(long long)numeric_limits<float>::round_style).data(),0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* numeric_limits<double> */
static void G__setup_memvarnumeric_limitslEdoublegR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__LN_numeric_limitslEdoublegR));
   { numeric_limits<double> *p; p=(numeric_limits<double>*)0x1000; if (p) { }
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_specialized=%lldLL",(long long)numeric_limits<double>::is_specialized).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("digits=%lldLL",(long long)numeric_limits<double>::digits).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("digits10=%lldLL",(long long)numeric_limits<double>::digits10).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_signed=%lldLL",(long long)numeric_limits<double>::is_signed).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_integer=%lldLL",(long long)numeric_limits<double>::is_integer).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_exact=%lldLL",(long long)numeric_limits<double>::is_exact).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("radix=%lldLL",(long long)numeric_limits<double>::radix).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("min_exponent=%lldLL",(long long)numeric_limits<double>::min_exponent).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("min_exponent10=%lldLL",(long long)numeric_limits<double>::min_exponent10).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("max_exponent=%lldLL",(long long)numeric_limits<double>::max_exponent).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("max_exponent10=%lldLL",(long long)numeric_limits<double>::max_exponent10).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_infinity=%lldLL",(long long)numeric_limits<double>::has_infinity).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_quiet_NaN=%lldLL",(long long)numeric_limits<double>::has_quiet_NaN).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_signaling_NaN=%lldLL",(long long)numeric_limits<double>::has_signaling_NaN).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__LN_float_denorm_style),-1,-2,1,G__FastAllocString(2048).Format("has_denorm=%lldLL",(long long)numeric_limits<double>::has_denorm).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_denorm_loss=%lldLL",(long long)numeric_limits<double>::has_denorm_loss).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_iec559=%lldLL",(long long)numeric_limits<double>::is_iec559).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_bounded=%lldLL",(long long)numeric_limits<double>::is_bounded).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_modulo=%lldLL",(long long)numeric_limits<double>::is_modulo).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("traps=%lldLL",(long long)numeric_limits<double>::traps).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("tinyness_before=%lldLL",(long long)numeric_limits<double>::tinyness_before).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__LN_float_round_style),-1,-2,1,G__FastAllocString(2048).Format("round_style=%lldLL",(long long)numeric_limits<double>::round_style).data(),0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* numeric_limits<long double> */
static void G__setup_memvarnumeric_limitslElongsPdoublegR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__LN_numeric_limitslElongsPdoublegR));
   { numeric_limits<long double> *p; p=(numeric_limits<long double>*)0x1000; if (p) { }
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_specialized=%lldLL",(long long)numeric_limits<long double>::is_specialized).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("digits=%lldLL",(long long)numeric_limits<long double>::digits).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("digits10=%lldLL",(long long)numeric_limits<long double>::digits10).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_signed=%lldLL",(long long)numeric_limits<long double>::is_signed).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_integer=%lldLL",(long long)numeric_limits<long double>::is_integer).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_exact=%lldLL",(long long)numeric_limits<long double>::is_exact).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("radix=%lldLL",(long long)numeric_limits<long double>::radix).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("min_exponent=%lldLL",(long long)numeric_limits<long double>::min_exponent).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("min_exponent10=%lldLL",(long long)numeric_limits<long double>::min_exponent10).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("max_exponent=%lldLL",(long long)numeric_limits<long double>::max_exponent).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("max_exponent10=%lldLL",(long long)numeric_limits<long double>::max_exponent10).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_infinity=%lldLL",(long long)numeric_limits<long double>::has_infinity).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_quiet_NaN=%lldLL",(long long)numeric_limits<long double>::has_quiet_NaN).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_signaling_NaN=%lldLL",(long long)numeric_limits<long double>::has_signaling_NaN).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__LN_float_denorm_style),-1,-2,1,G__FastAllocString(2048).Format("has_denorm=%lldLL",(long long)numeric_limits<long double>::has_denorm).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("has_denorm_loss=%lldLL",(long long)numeric_limits<long double>::has_denorm_loss).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_iec559=%lldLL",(long long)numeric_limits<long double>::is_iec559).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_bounded=%lldLL",(long long)numeric_limits<long double>::is_bounded).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("is_modulo=%lldLL",(long long)numeric_limits<long double>::is_modulo).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("traps=%lldLL",(long long)numeric_limits<long double>::traps).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,103,0,1,-1,-1,-2,1,G__FastAllocString(2048).Format("tinyness_before=%lldLL",(long long)numeric_limits<long double>::tinyness_before).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__LN_float_round_style),-1,-2,1,G__FastAllocString(2048).Format("round_style=%lldLL",(long long)numeric_limits<long double>::round_style).data(),0,(char*)NULL);
   }
   G__tag_memvar_reset();
}

extern "C" void G__cpp_setup_memvar() {
}
/***********************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
***********************************************************/

/*********************************************************
* Member function information setup for each class
*********************************************************/
static void G__setup_memfuncnumeric_limitslEboolgR(void) {
   /* numeric_limits<bool> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__LN_numeric_limitslEboolgR));
   G__memfunc_setup("min",324,G__climits_2_0_1, 103, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (bool (*)())(&numeric_limits<bool>::min) ), 0);
   G__memfunc_setup("max",326,G__climits_2_0_2, 103, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (bool (*)())(&numeric_limits<bool>::max) ), 0);
   G__memfunc_setup("epsilon",762,G__climits_2_0_3, 103, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (bool (*)())(&numeric_limits<bool>::epsilon) ), 0);
   G__memfunc_setup("round_error",1201,G__climits_2_0_4, 103, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (bool (*)())(&numeric_limits<bool>::round_error) ), 0);
   G__memfunc_setup("infinity",874,G__climits_2_0_5, 103, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (bool (*)())(&numeric_limits<bool>::infinity) ), 0);
   G__memfunc_setup("quiet_NaN",900,G__climits_2_0_6, 103, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (bool (*)())(&numeric_limits<bool>::quiet_NaN) ), 0);
   G__memfunc_setup("signaling_NaN",1304,G__climits_2_0_7, 103, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (bool (*)())(&numeric_limits<bool>::signaling_NaN) ), 0);
   G__memfunc_setup("denorm_min",1064,G__climits_2_0_8, 103, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (bool (*)())(&numeric_limits<bool>::denorm_min) ), 0);
   // automatic default constructor
   G__memfunc_setup("numeric_limits<bool>", 2058, G__climits_2_0_9, (int) ('i'), G__get_linked_tagnum(&G__LN_numeric_limitslEboolgR), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("numeric_limits<bool>", 2058, G__climits_2_0_10, (int) ('i'), G__get_linked_tagnum(&G__LN_numeric_limitslEboolgR), -1, 0, 1, 1, 1, 0, "u 'numeric_limits<bool>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~numeric_limits<bool>", 2184, G__climits_2_0_11, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__climits_2_0_12, (int) ('u'), G__get_linked_tagnum(&G__LN_numeric_limitslEboolgR), -1, 1, 1, 1, 1, 0, "u 'numeric_limits<bool>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncnumeric_limitslEchargR(void) {
   /* numeric_limits<char> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__LN_numeric_limitslEchargR));
   G__memfunc_setup("min",324,G__climits_3_0_1, 99, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (char (*)())(&numeric_limits<char>::min) ), 0);
   G__memfunc_setup("max",326,G__climits_3_0_2, 99, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (char (*)())(&numeric_limits<char>::max) ), 0);
   G__memfunc_setup("epsilon",762,G__climits_3_0_3, 99, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (char (*)())(&numeric_limits<char>::epsilon) ), 0);
   G__memfunc_setup("round_error",1201,G__climits_3_0_4, 99, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (char (*)())(&numeric_limits<char>::round_error) ), 0);
   G__memfunc_setup("infinity",874,G__climits_3_0_5, 99, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (char (*)())(&numeric_limits<char>::infinity) ), 0);
   G__memfunc_setup("quiet_NaN",900,G__climits_3_0_6, 99, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (char (*)())(&numeric_limits<char>::quiet_NaN) ), 0);
   G__memfunc_setup("signaling_NaN",1304,G__climits_3_0_7, 99, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (char (*)())(&numeric_limits<char>::signaling_NaN) ), 0);
   G__memfunc_setup("denorm_min",1064,G__climits_3_0_8, 99, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (char (*)())(&numeric_limits<char>::denorm_min) ), 0);
   // automatic default constructor
   G__memfunc_setup("numeric_limits<char>", 2044, G__climits_3_0_9, (int) ('i'), G__get_linked_tagnum(&G__LN_numeric_limitslEchargR), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("numeric_limits<char>", 2044, G__climits_3_0_10, (int) ('i'), G__get_linked_tagnum(&G__LN_numeric_limitslEchargR), -1, 0, 1, 1, 1, 0, "u 'numeric_limits<char>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~numeric_limits<char>", 2170, G__climits_3_0_11, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__climits_3_0_12, (int) ('u'), G__get_linked_tagnum(&G__LN_numeric_limitslEchargR), -1, 1, 1, 1, 1, 0, "u 'numeric_limits<char>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncnumeric_limitslEsignedsPchargR(void) {
   /* numeric_limits<signed char> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__LN_numeric_limitslEsignedsPchargR));
   G__memfunc_setup("min",324,G__climits_4_0_1, 99, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (char (*)())(&numeric_limits<signed char>::min) ), 0);
   G__memfunc_setup("max",326,G__climits_4_0_2, 99, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (char (*)())(&numeric_limits<signed char>::max) ), 0);
   G__memfunc_setup("epsilon",762,G__climits_4_0_3, 99, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (char (*)())(&numeric_limits<signed char>::epsilon) ), 0);
   G__memfunc_setup("round_error",1201,G__climits_4_0_4, 99, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (char (*)())(&numeric_limits<signed char>::round_error) ), 0);
   G__memfunc_setup("infinity",874,G__climits_4_0_5, 99, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (char (*)())(&numeric_limits<signed char>::infinity) ), 0);
   G__memfunc_setup("quiet_NaN",900,G__climits_4_0_6, 99, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (char (*)())(&numeric_limits<signed char>::quiet_NaN) ), 0);
   G__memfunc_setup("signaling_NaN",1304,G__climits_4_0_7, 99, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (char (*)())(&numeric_limits<signed char>::signaling_NaN) ), 0);
   G__memfunc_setup("denorm_min",1064,G__climits_4_0_8, 99, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (char (*)())(&numeric_limits<signed char>::denorm_min) ), 0);
   // automatic default constructor
   G__memfunc_setup("numeric_limits<signed char>", 2710, G__climits_4_0_9, (int) ('i'), 
G__get_linked_tagnum(&G__LN_numeric_limitslEsignedsPchargR), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("numeric_limits<signed char>", 2710, G__climits_4_0_10, (int) ('i'), 
G__get_linked_tagnum(&G__LN_numeric_limitslEsignedsPchargR), -1, 0, 1, 1, 1, 0, "u 'numeric_limits<signed char>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~numeric_limits<signed char>", 2836, G__climits_4_0_11, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__climits_4_0_12, (int) ('u'), G__get_linked_tagnum(&G__LN_numeric_limitslEsignedsPchargR), -1, 1, 1, 1, 1, 0, "u 'numeric_limits<signed char>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncnumeric_limitslEunsignedsPchargR(void) {
   /* numeric_limits<unsigned char> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__LN_numeric_limitslEunsignedsPchargR));
   G__memfunc_setup("min",324,G__climits_5_0_1, 98, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (unsigned char (*)())(&numeric_limits<unsigned char>::min) ), 0);
   G__memfunc_setup("max",326,G__climits_5_0_2, 98, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (unsigned char (*)())(&numeric_limits<unsigned char>::max) ), 0);
   G__memfunc_setup("epsilon",762,G__climits_5_0_3, 98, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (unsigned char (*)())(&numeric_limits<unsigned char>::epsilon) ), 0);
   G__memfunc_setup("round_error",1201,G__climits_5_0_4, 98, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (unsigned char (*)())(&numeric_limits<unsigned char>::round_error) ), 0);
   G__memfunc_setup("infinity",874,G__climits_5_0_5, 98, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (unsigned char (*)())(&numeric_limits<unsigned char>::infinity) ), 0);
   G__memfunc_setup("quiet_NaN",900,G__climits_5_0_6, 98, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (unsigned char (*)())(&numeric_limits<unsigned char>::quiet_NaN) ), 0);
   G__memfunc_setup("signaling_NaN",1304,G__climits_5_0_7, 98, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (unsigned char (*)())(&numeric_limits<unsigned char>::signaling_NaN) ), 0);
   G__memfunc_setup("denorm_min",1064,G__climits_5_0_8, 98, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (unsigned char (*)())(&numeric_limits<unsigned char>::denorm_min) ), 0);
   // automatic default constructor
   G__memfunc_setup("numeric_limits<unsigned char>", 2937, G__climits_5_0_9, (int) ('i'), 
G__get_linked_tagnum(&G__LN_numeric_limitslEunsignedsPchargR), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("numeric_limits<unsigned char>", 2937, G__climits_5_0_10, (int) ('i'), 
G__get_linked_tagnum(&G__LN_numeric_limitslEunsignedsPchargR), -1, 0, 1, 1, 1, 0, "u 'numeric_limits<unsigned char>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~numeric_limits<unsigned char>", 3063, G__climits_5_0_11, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__climits_5_0_12, (int) ('u'), G__get_linked_tagnum(&G__LN_numeric_limitslEunsignedsPchargR), -1, 1, 1, 1, 1, 0, "u 'numeric_limits<unsigned char>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncnumeric_limitslEunsignedsPintgR(void) {
   /* numeric_limits<unsigned int> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__LN_numeric_limitslEunsignedsPintgR));
   G__memfunc_setup("min",324,G__climits_6_0_1, 104, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (unsigned int (*)())(&numeric_limits<unsigned int>::min) ), 0);
   G__memfunc_setup("max",326,G__climits_6_0_2, 104, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (unsigned int (*)())(&numeric_limits<unsigned int>::max) ), 0);
   G__memfunc_setup("epsilon",762,G__climits_6_0_3, 104, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (unsigned int (*)())(&numeric_limits<unsigned int>::epsilon) ), 0);
   G__memfunc_setup("round_error",1201,G__climits_6_0_4, 104, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (unsigned int (*)())(&numeric_limits<unsigned int>::round_error) ), 0);
   G__memfunc_setup("infinity",874,G__climits_6_0_5, 104, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (unsigned int (*)())(&numeric_limits<unsigned int>::infinity) ), 0);
   G__memfunc_setup("quiet_NaN",900,G__climits_6_0_6, 104, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (unsigned int (*)())(&numeric_limits<unsigned int>::quiet_NaN) ), 0);
   G__memfunc_setup("signaling_NaN",1304,G__climits_6_0_7, 104, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (unsigned int (*)())(&numeric_limits<unsigned int>::signaling_NaN) ), 0);
   G__memfunc_setup("denorm_min",1064,G__climits_6_0_8, 104, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (unsigned int (*)())(&numeric_limits<unsigned int>::denorm_min) ), 0);
   // automatic default constructor
   G__memfunc_setup("numeric_limits<unsigned int>", 2854, G__climits_6_0_9, (int) ('i'), 
G__get_linked_tagnum(&G__LN_numeric_limitslEunsignedsPintgR), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("numeric_limits<unsigned int>", 2854, G__climits_6_0_10, (int) ('i'), 
G__get_linked_tagnum(&G__LN_numeric_limitslEunsignedsPintgR), -1, 0, 1, 1, 1, 0, "u 'numeric_limits<unsigned int>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~numeric_limits<unsigned int>", 2980, G__climits_6_0_11, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__climits_6_0_12, (int) ('u'), G__get_linked_tagnum(&G__LN_numeric_limitslEunsignedsPintgR), -1, 1, 1, 1, 1, 0, "u 'numeric_limits<unsigned int>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncnumeric_limitslEshortgR(void) {
   /* numeric_limits<short> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__LN_numeric_limitslEshortgR));
   G__memfunc_setup("min",324,G__climits_7_0_1, 115, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (short (*)())(&numeric_limits<short>::min) ), 0);
   G__memfunc_setup("max",326,G__climits_7_0_2, 115, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (short (*)())(&numeric_limits<short>::max) ), 0);
   G__memfunc_setup("epsilon",762,G__climits_7_0_3, 115, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (short (*)())(&numeric_limits<short>::epsilon) ), 0);
   G__memfunc_setup("round_error",1201,G__climits_7_0_4, 115, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (short (*)())(&numeric_limits<short>::round_error) ), 0);
   G__memfunc_setup("infinity",874,G__climits_7_0_5, 115, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (short (*)())(&numeric_limits<short>::infinity) ), 0);
   G__memfunc_setup("quiet_NaN",900,G__climits_7_0_6, 115, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (short (*)())(&numeric_limits<short>::quiet_NaN) ), 0);
   G__memfunc_setup("signaling_NaN",1304,G__climits_7_0_7, 115, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (short (*)())(&numeric_limits<short>::signaling_NaN) ), 0);
   G__memfunc_setup("denorm_min",1064,G__climits_7_0_8, 115, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (short (*)())(&numeric_limits<short>::denorm_min) ), 0);
   // automatic default constructor
   G__memfunc_setup("numeric_limits<short>", 2190, G__climits_7_0_9, (int) ('i'), G__get_linked_tagnum(&G__LN_numeric_limitslEshortgR), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("numeric_limits<short>", 2190, G__climits_7_0_10, (int) ('i'), 
G__get_linked_tagnum(&G__LN_numeric_limitslEshortgR), -1, 0, 1, 1, 1, 0, "u 'numeric_limits<short>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~numeric_limits<short>", 2316, G__climits_7_0_11, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__climits_7_0_12, (int) ('u'), G__get_linked_tagnum(&G__LN_numeric_limitslEshortgR), -1, 1, 1, 1, 1, 0, "u 'numeric_limits<short>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncnumeric_limitslEintgR(void) {
   /* numeric_limits<int> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__LN_numeric_limitslEintgR));
   G__memfunc_setup("min",324,G__climits_8_0_1, 105, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (int (*)())(&numeric_limits<int>::min) ), 0);
   G__memfunc_setup("max",326,G__climits_8_0_2, 105, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (int (*)())(&numeric_limits<int>::max) ), 0);
   G__memfunc_setup("epsilon",762,G__climits_8_0_3, 105, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (int (*)())(&numeric_limits<int>::epsilon) ), 0);
   G__memfunc_setup("round_error",1201,G__climits_8_0_4, 105, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (int (*)())(&numeric_limits<int>::round_error) ), 0);
   G__memfunc_setup("infinity",874,G__climits_8_0_5, 105, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (int (*)())(&numeric_limits<int>::infinity) ), 0);
   G__memfunc_setup("quiet_NaN",900,G__climits_8_0_6, 105, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (int (*)())(&numeric_limits<int>::quiet_NaN) ), 0);
   G__memfunc_setup("signaling_NaN",1304,G__climits_8_0_7, 105, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (int (*)())(&numeric_limits<int>::signaling_NaN) ), 0);
   G__memfunc_setup("denorm_min",1064,G__climits_8_0_8, 105, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (int (*)())(&numeric_limits<int>::denorm_min) ), 0);
   // automatic default constructor
   G__memfunc_setup("numeric_limits<int>", 1961, G__climits_8_0_9, (int) ('i'), G__get_linked_tagnum(&G__LN_numeric_limitslEintgR), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("numeric_limits<int>", 1961, G__climits_8_0_10, (int) ('i'), G__get_linked_tagnum(&G__LN_numeric_limitslEintgR), -1, 0, 1, 1, 1, 0, "u 'numeric_limits<int>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~numeric_limits<int>", 2087, G__climits_8_0_11, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__climits_8_0_12, (int) ('u'), G__get_linked_tagnum(&G__LN_numeric_limitslEintgR), -1, 1, 1, 1, 1, 0, "u 'numeric_limits<int>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncnumeric_limitslElonggR(void) {
   /* numeric_limits<long> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__LN_numeric_limitslElonggR));
   G__memfunc_setup("min",324,G__climits_9_0_1, 108, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (long (*)())(&numeric_limits<long>::min) ), 0);
   G__memfunc_setup("max",326,G__climits_9_0_2, 108, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (long (*)())(&numeric_limits<long>::max) ), 0);
   G__memfunc_setup("epsilon",762,G__climits_9_0_3, 108, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (long (*)())(&numeric_limits<long>::epsilon) ), 0);
   G__memfunc_setup("round_error",1201,G__climits_9_0_4, 108, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (long (*)())(&numeric_limits<long>::round_error) ), 0);
   G__memfunc_setup("infinity",874,G__climits_9_0_5, 108, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (long (*)())(&numeric_limits<long>::infinity) ), 0);
   G__memfunc_setup("quiet_NaN",900,G__climits_9_0_6, 108, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (long (*)())(&numeric_limits<long>::quiet_NaN) ), 0);
   G__memfunc_setup("signaling_NaN",1304,G__climits_9_0_7, 108, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (long (*)())(&numeric_limits<long>::signaling_NaN) ), 0);
   G__memfunc_setup("denorm_min",1064,G__climits_9_0_8, 108, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (long (*)())(&numeric_limits<long>::denorm_min) ), 0);
   // automatic default constructor
   G__memfunc_setup("numeric_limits<long>", 2062, G__climits_9_0_9, (int) ('i'), G__get_linked_tagnum(&G__LN_numeric_limitslElonggR), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("numeric_limits<long>", 2062, G__climits_9_0_10, (int) ('i'), G__get_linked_tagnum(&G__LN_numeric_limitslElonggR), -1, 0, 1, 1, 1, 0, "u 'numeric_limits<long>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~numeric_limits<long>", 2188, G__climits_9_0_11, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__climits_9_0_12, (int) ('u'), G__get_linked_tagnum(&G__LN_numeric_limitslElonggR), -1, 1, 1, 1, 1, 0, "u 'numeric_limits<long>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncnumeric_limitslEunsignedsPshortgR(void) {
   /* numeric_limits<unsigned short> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__LN_numeric_limitslEunsignedsPshortgR));
   G__memfunc_setup("min",324,G__climits_10_0_1, 114, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (unsigned short (*)())(&numeric_limits<unsigned short>::min) ), 0);
   G__memfunc_setup("max",326,G__climits_10_0_2, 114, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (unsigned short (*)())(&numeric_limits<unsigned short>::max) ), 0);
   G__memfunc_setup("epsilon",762,G__climits_10_0_3, 114, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (unsigned short (*)())(&numeric_limits<unsigned short>::epsilon) ), 0);
   G__memfunc_setup("round_error",1201,G__climits_10_0_4, 114, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (unsigned short (*)())(&numeric_limits<unsigned short>::round_error) ), 0);
   G__memfunc_setup("infinity",874,G__climits_10_0_5, 114, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (unsigned short (*)())(&numeric_limits<unsigned short>::infinity) ), 0);
   G__memfunc_setup("quiet_NaN",900,G__climits_10_0_6, 114, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (unsigned short (*)())(&numeric_limits<unsigned short>::quiet_NaN) ), 0);
   G__memfunc_setup("signaling_NaN",1304,G__climits_10_0_7, 114, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (unsigned short (*)())(&numeric_limits<unsigned short>::signaling_NaN) ), 0);
   G__memfunc_setup("denorm_min",1064,G__climits_10_0_8, 114, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (unsigned short (*)())(&numeric_limits<unsigned short>::denorm_min) ), 0);
   // automatic default constructor
   G__memfunc_setup("numeric_limits<unsigned short>", 3083, G__climits_10_0_9, (int) ('i'), 
G__get_linked_tagnum(&G__LN_numeric_limitslEunsignedsPshortgR), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("numeric_limits<unsigned short>", 3083, G__climits_10_0_10, (int) ('i'), 
G__get_linked_tagnum(&G__LN_numeric_limitslEunsignedsPshortgR), -1, 0, 1, 1, 1, 0, "u 'numeric_limits<unsigned short>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~numeric_limits<unsigned short>", 3209, G__climits_10_0_11, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__climits_10_0_12, (int) ('u'), G__get_linked_tagnum(&G__LN_numeric_limitslEunsignedsPshortgR), -1, 1, 1, 1, 1, 0, "u 'numeric_limits<unsigned short>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncnumeric_limitslEunsignedsPlonggR(void) {
   /* numeric_limits<unsigned long> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__LN_numeric_limitslEunsignedsPlonggR));
   G__memfunc_setup("min",324,G__climits_11_0_1, 107, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (unsigned long (*)())(&numeric_limits<unsigned long>::min) ), 0);
   G__memfunc_setup("max",326,G__climits_11_0_2, 107, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (unsigned long (*)())(&numeric_limits<unsigned long>::max) ), 0);
   G__memfunc_setup("epsilon",762,G__climits_11_0_3, 107, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (unsigned long (*)())(&numeric_limits<unsigned long>::epsilon) ), 0);
   G__memfunc_setup("round_error",1201,G__climits_11_0_4, 107, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (unsigned long (*)())(&numeric_limits<unsigned long>::round_error) ), 0);
   G__memfunc_setup("infinity",874,G__climits_11_0_5, 107, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (unsigned long (*)())(&numeric_limits<unsigned long>::infinity) ), 0);
   G__memfunc_setup("quiet_NaN",900,G__climits_11_0_6, 107, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (unsigned long (*)())(&numeric_limits<unsigned long>::quiet_NaN) ), 0);
   G__memfunc_setup("signaling_NaN",1304,G__climits_11_0_7, 107, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (unsigned long (*)())(&numeric_limits<unsigned long>::signaling_NaN) ), 0);
   G__memfunc_setup("denorm_min",1064,G__climits_11_0_8, 107, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (unsigned long (*)())(&numeric_limits<unsigned long>::denorm_min) ), 0);
   // automatic default constructor
   G__memfunc_setup("numeric_limits<unsigned long>", 2955, G__climits_11_0_9, (int) ('i'), 
G__get_linked_tagnum(&G__LN_numeric_limitslEunsignedsPlonggR), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("numeric_limits<unsigned long>", 2955, G__climits_11_0_10, (int) ('i'), 
G__get_linked_tagnum(&G__LN_numeric_limitslEunsignedsPlonggR), -1, 0, 1, 1, 1, 0, "u 'numeric_limits<unsigned long>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~numeric_limits<unsigned long>", 3081, G__climits_11_0_11, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__climits_11_0_12, (int) ('u'), G__get_linked_tagnum(&G__LN_numeric_limitslEunsignedsPlonggR), -1, 1, 1, 1, 1, 0, "u 'numeric_limits<unsigned long>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncnumeric_limitslEfloatgR(void) {
   /* numeric_limits<float> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__LN_numeric_limitslEfloatgR));
   G__memfunc_setup("min",324,G__climits_12_0_1, 102, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (float (*)())(&numeric_limits<float>::min) ), 0);
   G__memfunc_setup("max",326,G__climits_12_0_2, 102, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (float (*)())(&numeric_limits<float>::max) ), 0);
   G__memfunc_setup("epsilon",762,G__climits_12_0_3, 102, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (float (*)())(&numeric_limits<float>::epsilon) ), 0);
   G__memfunc_setup("round_error",1201,G__climits_12_0_4, 102, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (float (*)())(&numeric_limits<float>::round_error) ), 0);
   G__memfunc_setup("infinity",874,G__climits_12_0_5, 102, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (float (*)())(&numeric_limits<float>::infinity) ), 0);
   G__memfunc_setup("quiet_NaN",900,G__climits_12_0_6, 102, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (float (*)())(&numeric_limits<float>::quiet_NaN) ), 0);
   G__memfunc_setup("signaling_NaN",1304,G__climits_12_0_7, 102, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (float (*)())(&numeric_limits<float>::signaling_NaN) ), 0);
   G__memfunc_setup("denorm_min",1064,G__climits_12_0_8, 102, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (float (*)())(&numeric_limits<float>::denorm_min) ), 0);
   // automatic default constructor
   G__memfunc_setup("numeric_limits<float>", 2164, G__climits_12_0_9, (int) ('i'), G__get_linked_tagnum(&G__LN_numeric_limitslEfloatgR), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("numeric_limits<float>", 2164, G__climits_12_0_10, (int) ('i'), 
G__get_linked_tagnum(&G__LN_numeric_limitslEfloatgR), -1, 0, 1, 1, 1, 0, "u 'numeric_limits<float>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~numeric_limits<float>", 2290, G__climits_12_0_11, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__climits_12_0_12, (int) ('u'), G__get_linked_tagnum(&G__LN_numeric_limitslEfloatgR), -1, 1, 1, 1, 1, 0, "u 'numeric_limits<float>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncnumeric_limitslEdoublegR(void) {
   /* numeric_limits<double> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__LN_numeric_limitslEdoublegR));
   G__memfunc_setup("min",324,G__climits_13_0_1, 100, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (double (*)())(&numeric_limits<double>::min) ), 0);
   G__memfunc_setup("max",326,G__climits_13_0_2, 100, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (double (*)())(&numeric_limits<double>::max) ), 0);
   G__memfunc_setup("epsilon",762,G__climits_13_0_3, 100, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (double (*)())(&numeric_limits<double>::epsilon) ), 0);
   G__memfunc_setup("round_error",1201,G__climits_13_0_4, 100, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (double (*)())(&numeric_limits<double>::round_error) ), 0);
   G__memfunc_setup("infinity",874,G__climits_13_0_5, 100, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (double (*)())(&numeric_limits<double>::infinity) ), 0);
   G__memfunc_setup("quiet_NaN",900,G__climits_13_0_6, 100, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (double (*)())(&numeric_limits<double>::quiet_NaN) ), 0);
   G__memfunc_setup("signaling_NaN",1304,G__climits_13_0_7, 100, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (double (*)())(&numeric_limits<double>::signaling_NaN) ), 0);
   G__memfunc_setup("denorm_min",1064,G__climits_13_0_8, 100, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (double (*)())(&numeric_limits<double>::denorm_min) ), 0);
   // automatic default constructor
   G__memfunc_setup("numeric_limits<double>", 2265, G__climits_13_0_9, (int) ('i'), G__get_linked_tagnum(&G__LN_numeric_limitslEdoublegR), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("numeric_limits<double>", 2265, G__climits_13_0_10, (int) ('i'), 
G__get_linked_tagnum(&G__LN_numeric_limitslEdoublegR), -1, 0, 1, 1, 1, 0, "u 'numeric_limits<double>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~numeric_limits<double>", 2391, G__climits_13_0_11, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__climits_13_0_12, (int) ('u'), G__get_linked_tagnum(&G__LN_numeric_limitslEdoublegR), -1, 1, 1, 1, 1, 0, "u 'numeric_limits<double>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncnumeric_limitslElongsPdoublegR(void) {
   /* numeric_limits<long double> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__LN_numeric_limitslElongsPdoublegR));
   G__memfunc_setup("min",324,G__climits_14_0_1, 113, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (long double (*)())(&numeric_limits<long double>::min) ), 0);
   G__memfunc_setup("max",326,G__climits_14_0_2, 113, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (long double (*)())(&numeric_limits<long double>::max) ), 0);
   G__memfunc_setup("epsilon",762,G__climits_14_0_3, 113, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (long double (*)())(&numeric_limits<long double>::epsilon) ), 0);
   G__memfunc_setup("round_error",1201,G__climits_14_0_4, 113, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (long double (*)())(&numeric_limits<long double>::round_error) ), 0);
   G__memfunc_setup("infinity",874,G__climits_14_0_5, 113, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (long double (*)())(&numeric_limits<long double>::infinity) ), 0);
   G__memfunc_setup("quiet_NaN",900,G__climits_14_0_6, 113, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (long double (*)())(&numeric_limits<long double>::quiet_NaN) ), 0);
   G__memfunc_setup("signaling_NaN",1304,G__climits_14_0_7, 113, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (long double (*)())(&numeric_limits<long double>::signaling_NaN) ), 0);
   G__memfunc_setup("denorm_min",1064,G__climits_14_0_8, 113, -1, -1, 0, 0, 3, 1, 32, "", (char*)NULL, (void*) G__func2void( (long double (*)())(&numeric_limits<long double>::denorm_min) ), 0);
   // automatic default constructor
   G__memfunc_setup("numeric_limits<long double>", 2729, G__climits_14_0_9, (int) ('i'), 
G__get_linked_tagnum(&G__LN_numeric_limitslElongsPdoublegR), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("numeric_limits<long double>", 2729, G__climits_14_0_10, (int) ('i'), 
G__get_linked_tagnum(&G__LN_numeric_limitslElongsPdoublegR), -1, 0, 1, 1, 1, 0, "u 'numeric_limits<long double>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~numeric_limits<long double>", 2855, G__climits_14_0_11, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__climits_14_0_12, (int) ('u'), G__get_linked_tagnum(&G__LN_numeric_limitslElongsPdoublegR), -1, 1, 1, 1, 1, 0, "u 'numeric_limits<long double>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}


/*********************************************************
* Member function information setup
*********************************************************/
extern "C" void G__cpp_setup_memfunc() {
}

/*********************************************************
* Global variable information setup for each class
*********************************************************/
static void G__cpp_setup_global0() {

   /* Setting up global variables */
   G__resetplocal();

   G__memvar_setup((void*)G__PVOID,112,0,0,-1,-1,-1,1,"__GNUC__=4",1,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,112,0,0,-1,-1,-1,1,"__GNUC_MINOR__=3",1,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,112,0,0,-1,-1,-1,1,"G__CLIMITS_DLL=0",1,(char*)NULL);

   G__resetglobalenv();
}
extern "C" void G__cpp_setup_global() {
  G__cpp_setup_global0();
}

/*********************************************************
* Global function information setup for each class
*********************************************************/
static void G__cpp_setup_func0() {
   G__lastifuncposition();


   G__resetifuncposition();
}

extern "C" void G__cpp_setup_func() {
  G__cpp_setup_func0();
}

/*********************************************************
* Class,struct,union,enum tag information setup
*********************************************************/
/* Setup class/struct taginfo */
G__linked_taginfo G__LN_float_round_style = { "float_round_style" , 101 , -1 };
G__linked_taginfo G__LN_float_denorm_style = { "float_denorm_style" , 101 , -1 };
G__linked_taginfo G__LN_numeric_limitslEboolgR = { "numeric_limits<bool>" , 99 , -1 };
G__linked_taginfo G__LN_numeric_limitslEchargR = { "numeric_limits<char>" , 99 , -1 };
G__linked_taginfo G__LN_numeric_limitslEsignedsPchargR = { "numeric_limits<signed char>" , 99 , -1 };
G__linked_taginfo G__LN_numeric_limitslEunsignedsPchargR = { "numeric_limits<unsigned char>" , 99 , -1 };
G__linked_taginfo G__LN_numeric_limitslEunsignedsPintgR = { "numeric_limits<unsigned int>" , 99 , -1 };
G__linked_taginfo G__LN_numeric_limitslEshortgR = { "numeric_limits<short>" , 99 , -1 };
G__linked_taginfo G__LN_numeric_limitslEintgR = { "numeric_limits<int>" , 99 , -1 };
G__linked_taginfo G__LN_numeric_limitslElonggR = { "numeric_limits<long>" , 99 , -1 };
G__linked_taginfo G__LN_numeric_limitslEunsignedsPshortgR = { "numeric_limits<unsigned short>" , 99 , -1 };
G__linked_taginfo G__LN_numeric_limitslEunsignedsPlonggR = { "numeric_limits<unsigned long>" , 99 , -1 };
G__linked_taginfo G__LN_numeric_limitslEfloatgR = { "numeric_limits<float>" , 99 , -1 };
G__linked_taginfo G__LN_numeric_limitslEdoublegR = { "numeric_limits<double>" , 99 , -1 };
G__linked_taginfo G__LN_numeric_limitslElongsPdoublegR = { "numeric_limits<long double>" , 99 , -1 };

/* Reset class/struct taginfo */
extern "C" void G__cpp_reset_tagtable() {
  G__LN_float_round_style.tagnum = -1 ;
  G__LN_float_denorm_style.tagnum = -1 ;
  G__LN_numeric_limitslEboolgR.tagnum = -1 ;
  G__LN_numeric_limitslEchargR.tagnum = -1 ;
  G__LN_numeric_limitslEsignedsPchargR.tagnum = -1 ;
  G__LN_numeric_limitslEunsignedsPchargR.tagnum = -1 ;
  G__LN_numeric_limitslEunsignedsPintgR.tagnum = -1 ;
  G__LN_numeric_limitslEshortgR.tagnum = -1 ;
  G__LN_numeric_limitslEintgR.tagnum = -1 ;
  G__LN_numeric_limitslElonggR.tagnum = -1 ;
  G__LN_numeric_limitslEunsignedsPshortgR.tagnum = -1 ;
  G__LN_numeric_limitslEunsignedsPlonggR.tagnum = -1 ;
  G__LN_numeric_limitslEfloatgR.tagnum = -1 ;
  G__LN_numeric_limitslEdoublegR.tagnum = -1 ;
  G__LN_numeric_limitslElongsPdoublegR.tagnum = -1 ;
}


extern "C" void G__cpp_setup_tagtable() {

   /* Setting up class,struct,union tag entry */
   G__get_linked_tagnum_fwd(&G__LN_float_round_style);
   G__get_linked_tagnum_fwd(&G__LN_float_denorm_style);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__LN_numeric_limitslEboolgR),sizeof(numeric_limits<bool>),-1,0,(char*)NULL,G__setup_memvarnumeric_limitslEboolgR,G__setup_memfuncnumeric_limitslEboolgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__LN_numeric_limitslEchargR),sizeof(numeric_limits<char>),-1,0,(char*)NULL,G__setup_memvarnumeric_limitslEchargR,G__setup_memfuncnumeric_limitslEchargR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__LN_numeric_limitslEsignedsPchargR),sizeof(numeric_limits<signed char>),-1,0,(char*)NULL,G__setup_memvarnumeric_limitslEsignedsPchargR,G__setup_memfuncnumeric_limitslEsignedsPchargR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__LN_numeric_limitslEunsignedsPchargR),sizeof(numeric_limits<unsigned char>),-1,0,(char*)NULL,G__setup_memvarnumeric_limitslEunsignedsPchargR,G__setup_memfuncnumeric_limitslEunsignedsPchargR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__LN_numeric_limitslEunsignedsPintgR),sizeof(numeric_limits<unsigned int>),-1,0,(char*)NULL,G__setup_memvarnumeric_limitslEunsignedsPintgR,G__setup_memfuncnumeric_limitslEunsignedsPintgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__LN_numeric_limitslEshortgR),sizeof(numeric_limits<short>),-1,0,(char*)NULL,G__setup_memvarnumeric_limitslEshortgR,G__setup_memfuncnumeric_limitslEshortgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__LN_numeric_limitslEintgR),sizeof(numeric_limits<int>),-1,0,(char*)NULL,G__setup_memvarnumeric_limitslEintgR,G__setup_memfuncnumeric_limitslEintgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__LN_numeric_limitslElonggR),sizeof(numeric_limits<long>),-1,0,(char*)NULL,G__setup_memvarnumeric_limitslElonggR,G__setup_memfuncnumeric_limitslElonggR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__LN_numeric_limitslEunsignedsPshortgR),sizeof(numeric_limits<unsigned short>),-1,0,(char*)NULL,G__setup_memvarnumeric_limitslEunsignedsPshortgR,G__setup_memfuncnumeric_limitslEunsignedsPshortgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__LN_numeric_limitslEunsignedsPlonggR),sizeof(numeric_limits<unsigned long>),-1,0,(char*)NULL,G__setup_memvarnumeric_limitslEunsignedsPlonggR,G__setup_memfuncnumeric_limitslEunsignedsPlonggR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__LN_numeric_limitslEfloatgR),sizeof(numeric_limits<float>),-1,0,(char*)NULL,G__setup_memvarnumeric_limitslEfloatgR,G__setup_memfuncnumeric_limitslEfloatgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__LN_numeric_limitslEdoublegR),sizeof(numeric_limits<double>),-1,0,(char*)NULL,G__setup_memvarnumeric_limitslEdoublegR,G__setup_memfuncnumeric_limitslEdoublegR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__LN_numeric_limitslElongsPdoublegR),sizeof(numeric_limits<long double>),-1,0,(char*)NULL,G__setup_memvarnumeric_limitslElongsPdoublegR,G__setup_memfuncnumeric_limitslElongsPdoublegR);
}
extern "C" void G__cpp_setup(void) {
  G__check_setup_version(30051515,"G__cpp_setup()");
  G__set_cpp_environment();
  G__cpp_setup_tagtable();

  G__cpp_setup_inheritance();

  G__cpp_setup_typetable();

  G__cpp_setup_memvar();

  G__cpp_setup_memfunc();
  G__cpp_setup_global();
  G__cpp_setup_func();

   if(0==G__getsizep2memfunc()) G__get_sizep2memfunc();
  return;
}
class G__cpp_setup_init {
  public:
    G__cpp_setup_init() { G__add_setup_func("G__Default",(G__incsetup)(&G__cpp_setup)); }
   ~G__cpp_setup_init() { G__remove_setup_func("G__Default"); }
};
G__cpp_setup_init G__cpp_setup_initializer;

